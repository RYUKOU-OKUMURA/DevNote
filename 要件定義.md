## 【要件定義書】GitHubリポジトリ対話AIアプリ (Ver. 2.0)

### 1. プロジェクト概要

#### 1.1. プロジェクト名
DevNote

#### 1.2. 目的
指定されたGitHubリポジトリをAIが学習し、ユーザーが**Notebook LM風の専用ワークスペース**で、リポジトリのコードやドキュメントについて対話的に質問できるRAG（検索拡張生成）アプリケーションを開発する。

#### 1.3. コアバリュー
* **コンテキストの分離:** 1リポジトリを1つの独立した「ノート（ワークスペース）」として扱い、チャット履歴やメモをリポジトリごとに明確に分離・保存する。
* **3要素の連携:** 「ソース（ファイルツリー）」「対話（チャット）」「知見（メモパッド）」を1画面に統合し、シームレスなコード調査体験を提供する。
* **根拠の明示 (Citation):** AIの回答は、Gemini APIのFile Search機能に基づき、リポジトリ内のどのファイルに由来するかという「引用」を必ず明示する。

---

### 2. 画面遷移と全体フロー

1.  **[ / ] (トップ/認証)**: ユーザーはGitHub OAuthでログインする。
2.  **[ /dashboard ] (ダッシュボード)**: ログイン後、このページにリダイレクトされる。
3.  **[ /dashboard ]**: ユーザーが過去に登録した「リポジトリノート」がカード形式で一覧表示される。「新規ノート作成」ボタンからリポジトリを登録する。
4.  **[ /workspace/{id} ] (ワークスペース)**: ダッシュボードで特定のノートを選択すると、このメインの3カラムUIページに遷移する。`{id}`はノート（リポジトリ）固有のID。

---

### 3. 機能要件

#### 3.1. ユーザー認証
* **[MUST]** GitHub OAuth (『DevBoard』と同様) を使用し、ユーザーはGitHubアカウントでログインできる。
* **[MUST]** ユーザーのリポジトリ（公開・非公開問わず）を読み取るための適切なスコープを要求する。

#### 3.2. ダッシュボード機能 (`/dashboard`)
* **[MUST]** ユーザーが登録した「リポジトリノート」を一覧表示する。各ノートにはリポジトリ名や最終更新日を表示する。
* **[MUST]** 「新規リポジトリノート作成」機能を持つ。
    * ユーザーは自身のリポジトリ一覧から選択、またはGitHubリポジトリのURLを貼り付ける。
    * 登録が選択されると、バックエンドが非同期で「3.3. データ同期」処理を開始する。
    * 一覧画面ではインデックス作成中のステータス（例：「準備中...」）を表示する。
* **[MUST]** 既存のノートを選択すると、該当するワークスペースページ (`/workspace/{id}`) に遷移する。
* **[MUST]** ノートカードは状態を明示し、ユーザーが次のアクションを理解できるようにする。
    * `Indexing`（準備中）、`Ready`（利用可能）、`Failed`（同期失敗）、`Auth Required`（GitHub認証エラー）の少なくとも4状態を扱い、エラー時は原因・再試行方法を表示する。
    * インデックスが失敗した場合は「再試行」ボタンと、サポート連絡先またはログビューへの導線を表示する。
* **[MUST]** 各ノートに最終同期日時と「再同期」ボタンを表示し、ユーザーが手動でデータ同期を再実行できるようにする。
* **[SHOULD]** ノートカードからチャット履歴のエクスポート操作（Markdownなど）を呼び出せる導線を設ける。

#### 3.3. データ同期・インデックス (バックエンド)
* **[MUST]** 新規ノート作成がトリガーされると、バックエンド（Cloudflare Workerなど）が起動する。
* **[MUST]** バックエンドはGitHub APIを介し、対象リポジトリの全ファイル（コード、Markdownなど）を取得する。
* **[MUST]** バックエンドは取得したファイル群を **Gemini API (File Search Tool)** の「File Store」にアップロードする。
    * **注:** チャンキング、Embedding、ベクトルDB管理はすべてGemini API側に一任する。
* **[MUST]** 1つの「リポジトリノート（Workspace）」と1つの「Gemini File Store」が1対1で紐づくよう管理する。
* **[MUST]** 再同期時は既存のFile Storeを安全に削除した上で最新ファイルを再アップロードし、チャット履歴の文脈メタデータ（最終同期バージョン）を更新する。
* **[MUST]** ノート削除やGitHubアクセス権の取り消し時には、関連するGemini File Store・GitHub一時キャッシュ・チャット/メモデータを24時間以内に削除するライフサイクルを定義する。
* **[SHOULD]** 同期処理の進捗・エラー情報をCloudflare WorkersのDurable Objectまたはログで追跡し、ダッシュボードから参照できるようにする。

#### 3.3.1. リポジトリ更新・同期
* **[MUST]** 手動「再同期」ボタンの実行でバックエンドが最新のコミットを取得し、最終同期日時を更新する。
* **[MUST]** バックエンドは同期タスクにジョブIDを付与し、失敗時に最大3回の自動リトライを行う。
* **[MUST]** ノート詳細には最終同期日時と直近の同期結果（成功/失敗理由）を表示する。
* **[MUST]** Gemini File Search APIの制約（ファイルフィルタリング可否、File Storeサイズ）をPoCで検証し、結果を要件のAppendixとして記録する。
* **[SHOULD]** Phase 2でGitHub Webhookを用いた自動再同期を検討し、現時点ではジョブスケジューラ（Workers Cron）による定期チェックを行う。
* **[SHOULD]** フル同期が難しい巨大リポジトリでは、直近で変更されたファイルのみを部分同期する段階的更新モードをサポートする。

#### 3.4. ワークスペース機能 (`/workspace/{id}`)
* **[MUST]** 画面は永続的な3カラムレイアウトを採用する。

##### 3.4.1. 左カラム (ソース: ファイルツリー)
* **[MUST]** 現在のワークスペース（リポジトリ）のファイル階層（ディレクトリツリー）を常時表示する。
* **[MUST]** ファイルやフォルダをクリック（または展開）できる。
* **[SHOULD]** ユーザーが特定のファイルをクリックすると、そのファイルが「コンテキストとして選択中」であることがUI上で明示される（例：ハイライト）。

##### 3.4.2. 中央カラム (対話: チャット)
* **[MUST]** チャットUI（会話履歴、入力ボックス）を表示する。
* **[MUST]** このワークスペース（リポジトリ）のチャット履歴は永続化され、次回訪問時に復元される。
* **[MUST]** 質問を送信すると、バックエンドは **Gemini API (File Search Tool)** と連携して回答を生成する。
    * **デフォルト:** リポジトリ全体（File Store全体）をコンテキストとして回答する。
    * **コンテキスト指定時:** もし左カラムで特定ファイルが選択されている場合、そのファイルを優先的に参照するようプロンプト（またはAPIの機能）で指示する。
    * **コンテキスト契約:** フロントエンドは選択されたファイルパス配列をAPIペイロードに含め、バックエンドはGemini File Searchのフィルタリング機能（利用不可の場合はプロンプト指示）で優先度を反映する。対象ファイルがGeminiの制限を超える場合は警告を返す。
* **[MUST] (引用表示)**
    * AIの回答には、Gemini APIが返す引用情報に基づき、根拠となったファイル名や箇所を `[引用: src/main.js]` の形式で明記する。
* **[SHOULD]** 回答はストリーミング（逐次表示）で行う。
* **[SHOULD]** チャット入力欄からコード検索モード（ファイル名・関数名フィルタ）に切り替え、該当ファイルへジャンプできるようにする。

##### 3.4.3. 右カラム (知見: メモパッド)
* **[MUST]** 自由にテキストを入力・編集できる「メモパッド」エリアを表示する。
* **[MUST]** このメモパッドの内容は、現在のワークスペース（リポジトリ）専用であり、永続化され、次回訪問時に復元される。
* **[SHOULD]** 中央カラムのチャット（質問や回答）を、ワンクリックで右カラムのメモパッドに「ピン留め（転記）」できるボタンを設置する。

##### 3.4.4. レイアウト / レスポンシブ
* **[MUST]** デスクトップでは3カラム固定レイアウト（左20% / 中央50% / 右30%）を維持し、パディングや余白が崩れないようにする。
* **[MUST]** タブレット幅では中央カラムをデフォルト表示とし、左右カラムをタブ切り替えで表示する。
* **[MUST]** モバイルでは下部タブまたはスワイプ操作で3領域を切り替えるUIを提供し、入力エリアが画面から隠れないようにする。
* **[SHOULD]** キーボードショートカット（例: `⌘+K`で検索、`p`でメモピン）をPhase 2で追加できるようUI構成を設計する。

#### 3.5. データ永続化
* **[MUST]** Cloudflare D1を用い、ユーザーテーブル、ノートテーブル、チャット履歴テーブル、ピン留めログテーブルを管理する。
* **[MUST]** ノートテーブルにはGitHubリポジトリ識別子、Gemini File Store ID、最終同期日時、ステータス、最新コミットSHAを保存する。
* **[MUST]** メモパッドの内容はノートと1対1で紐づけ、D1またはCloudflare KVのいずれかに保存する（保存先の理由とリテンションポリシーを決定する）。
* **[MUST]** 同期ジョブやエラーログはDurable ObjectまたはD1でトラッキングし、UIから確認できる。
* **[SHOULD]** Gemini File Store IDとローカルキャッシュ（例: R2に格納したZIP）の関係を記録し、再同期時の差分取得を最適化する。

---

### 4. 非機能要件

#### 4.1. 主要技術スタック (想定)
* **フロントエンド:** React (Vite / Next.js)
* **バックエンド / API:** Cloudflare Workers (または Pages Functions)
* **RAG / LLM:** **Google Gemini API (File Search Tool)**
* **認証:** GitHub OAuth
* **デプロイ:** Cloudflare Pages

#### 4.2. セキュリティ
* **[MUST]** GitHubアクセストークンとGemini APIキーはCloudflare Workersの暗号化環境変数に保存し、ログやクライアントに露出させない。
* **[MUST]** すべてのAPI呼び出しでJWTを検証し、ユーザーIDとノートIDの所有権を照合する。
* **[MUST]** File Store IDとD1上のノートはユーザーIDと1対1で紐づけ、アクセス時に必ず所有権チェックを行う。
* **[MUST]** プライベートリポジトリへアクセスするトークンは有効期限付きで保管し、再同期時に失効していた場合は`Auth Required`ステータスを返す。
* **[SHOULD]** 重要な操作（ノート削除、再同期開始）には監査ログを記録し、Cloudflare Logsに出力する。

#### 4.3. パフォーマンス
* **[MUST]** チャットの応答はストリーミングで体感速度を向上させる。
* **[SHOULD]** リポジトリの初回インデックス処理は非同期（バックグラウンド）で行い、ユーザーを待たせない。

#### 4.4. 制限事項・エラーハンドリング
* **[MUST]** リポジトリサイズの上限は500MBとし、超過時は警告と推奨対処（部分同期や対象ディレクトリ指定）を表示する。
* **[MUST]** `.git`ディレクトリや明らかなバイナリファイルは同期対象から除外する。
* **[MUST]** インデックス失敗時は最大3回まで自動リトライし、それでも失敗した場合は`Failed`ステータスとエラー詳細をユーザーに通知する。
* **[MUST]** Gemini APIのレート制限やFile Store制限に達した場合、ユーザーへ通知し、再試行までの待ち時間を表示する。
* **[SHOULD]** 失敗したファイル一覧を確認できるダイアログを提供し、ダウンロード不可ファイルの扱い方を提示する。

#### 4.5. コスト管理 / スケーラビリティ
* **[MUST]** ユーザーあたりのFile Store作成数を上限（例: 10件）に制限し、超過時は既存ノートの整理を促す。
* **[MUST]** 90日以上アクセスのないノートに対して自動アーカイブを通知し、File Store削除またはR2アーカイブ移行を選択できるようにする。
* **[MUST]** Gemini API利用量（ファイル転送量・検索API呼び出し）をメトリクスとして収集し、しきい値超過時にアラートを発火する。
* **[SHOULD]** File Store削除時にR2へ軽量なバックアップ（必要最低限のメタデータ）を残し、再インポート時のコストを最小化する。

### 5. ロードマップ

#### 5.1. Phase 1 (MVP)
* 手動再同期、状態管理、チャット引用表示、メモパッド永続化を完成させる。
* コード検索（ファイル名・関数名フィルタ）とチャット履歴のMarkdownエクスポートを提供する。

#### 5.2. Phase 2以降
* GitHub Webhookによる自動再同期、キーボードショートカットなどの生産性向上機能。
* 複数リポジトリ横断検索、チーム共有、GitHub Issue連携などのコラボレーション機能。

---

### Appendix A: Gemini File Search PoC 検証結果

**検証日時**: 2025-11-15

#### A.1. メタデータフィルタリング機能（タスク14.1）

**検証結果**: ✅ 成功

Gemini File Search APIは、メタデータフィルタリング機能を公式にサポートしています。主な発見:

* ファイルアップロード時にカスタムメタデータ（例: `file_path`, `file_type`）を付与可能
* クエリ実行時に`metadata_filter`パラメータでフィルタリング可能
* フィルタ構文: `file_path="src/main.ts"` または `file_path="src/main.ts" OR file_path="src/utils.ts"`
* 推定精度: 95-100%（APIレベルで検索範囲を制限するため高精度）

**実装方針**:
1. `uploadToGemini`関数で各ファイルに`file_path`メタデータを付与
2. `streamGeminiResponse`関数で選択ファイルがある場合は`metadata_filter`を適用
3. フィルタ構文エラー時は全体検索にフォールバック

#### A.2. File Storeサイズ制限（タスク14.2）

**検証結果**: ✅ 成功

公式ドキュメントおよびコミュニティ情報から得られた制限:

* File Store当たりの最大ファイル数: **10,000ファイル**
* 単一ファイルの最大サイズ: **2GB**
* File Store全体のサイズ: 明示的な制限なし（ただし大規模化するとパフォーマンスに影響）

**500MBリポジトリの動作予測**:
* 一般的なリポジトリでは500-2,000ファイル程度
* バイナリファイル除外後、テキストファイルは200-1,000程度
* **結論**: 10,000ファイル制限内に収まる可能性が非常に高い

**推奨事項**:
1. リポジトリサイズを500MBに制限し、超過時は警告表示
2. ファイル数が10,000を超える場合は、バイナリファイルや大きいファイルを除外
3. 大規模リポジトリでは部分同期（特定ディレクトリのみ）をサポート（Phase 2）

#### A.3. コンテキスト指定実装方針（タスク14.3）

**検証結果**: ✅ 成功

**比較評価**:

| 項目 | メタデータフィルタリング | プロンプト指示 |
|------|--------------------------|----------------|
| 精度 | 95-100% | 70-85% |
| 速度 | 高速 | 低速 |
| トークン使用量 | 少ない | 多い |
| 実装難易度 | 中程度 | 簡単 |
| コスト | 低 | 高 |

**最終決定**: ✅ **メタデータフィルタリング方式を採用**

**採用理由**:
1. 高精度（選択ファイルのみを確実に参照）
2. コスト削減（トークン使用量が削減）
3. 高速レスポンス（UX向上）
4. 公式サポート（Gemini File Search APIの標準機能）

**実装方針**:
* Phase 1: メタデータフィルタリングのみを実装
* Phase 2: プロンプト指示の併用を検討（精度向上）

詳細な検証結果は、プロジェクトルートの`gemini-poc-results.md`を参照してください。
